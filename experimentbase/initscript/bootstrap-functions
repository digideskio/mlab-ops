#!/bin/bash

# SETUP FUNCTIONS
function sanity_checks () {
    # SANITY CHECKS AND ENVIRONMENT SETUP

    # check default permission mask
    m=$( umask )
    if [ $m = "0000" ] ; then
        echo "Please set umask to a sensible default: i.e. umask 0022"
        exit 1
    fi

    # check for root user
    if [ $UID -ne "0" ] ; then
       echo "You must run this program with root permissions..."
       exit 1
    fi

    # check that slice name is given or saved.
    if [ -z "$SLICENAME" ] && [ ! -f /etc/slicename ] ; then
        echo "Please pass the slicename as the second argument"
        exit 1
    fi

    # if it's given then save it.
    if [ -n "$SLICENAME" ] ; then
        # SAVE SLICENAME
        echo $SLICENAME > /etc/slicename
    fi

    if ! enough_disk_space ; then
        echo "There is not enough disk space to continue!"
        exit 1
    fi
}

function get_package_and_verify () {
    # filename for the publickey we will use to verify the stage2 initscript
    PUBKEY_FN=`mktemp /tmp/publickey.XXXXXXXXXX`

    # filename for the extract stage2 initscript
    STAGE2_FN=`mktemp /tmp/stage2-initscript.XXXXXXXXXX`

    # URL for the stage2 initscript
    STAGE2_URL="$1"
    STAGE2_FILE=$( basename $STAGE2_URL )

    # filename and URL for the signature of the stage2 initscript
    STAGE2_SIGNATURE_FN=$STAGE2_FN.sig
    STAGE2_SIGNATURE_URL=$STAGE2_URL.sig

    # create the public key file
    cat <<EOF > $PUBKEY_FN
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhB8rNF0EH9DfjMw2mDGTYur/N
MmaQaiXICDaxlL1MppY9B6GFQVDbthrqM9HjBUUyDUnQ1jrOjE0II7QKeSc5Gqys
8e8S92stMzdSvtcogfhJcYElq9pCXLbzxI7xzRRoK1zEuKPz3Op5wDjUj1x8/x02
LfnWuuFYf4U5JCRoRwIDAQAB
-----END PUBLIC KEY-----
EOF

    DELAY=1
    RETRY=1

    while [ $RETRY -eq 1 ]; do
       # break out of loop by default
       RETRY=0

       # download the stage2 initscript
       curl -s -o $STAGE2_FN $STAGE2_URL 
       if [ ! -f $STAGE2_FN -o $? -ne 0 ]
       then
          echo "Failed to download $STAGE2_URL"
          RETRY=1
       fi

       # download the signature
       if [ $RETRY -eq 0 ]; then
          curl -s -o $STAGE2_SIGNATURE_FN $STAGE2_SIGNATURE_URL
          if [ ! -f $STAGE2_SIGNATURE_FN -o $? -ne 0 ]
          then
             echo "Failed to download $STAGE2_SIGNATURE_URL"
             RETRY=1
          fi
       fi

       # make sure the signature is correct
       if [ $RETRY -eq 0 ]; then
          # verify the signature
          RESULT=`openssl dgst -sha256 -signature $STAGE2_SIGNATURE_FN -verify $PUBKEY_FN $STAGE2_FN`
          echo "Signature Verification: $RESULT"
          if [ "$RESULT" != "Verified OK" ]; then
             echo "OpenSSL failed to verify $STAGE2_SIGNATURE_FN"
             RETRY=1
          fi
       fi

       # if something went wrong, then retry. This covers connection errors as
       # well as problems with the stork repository itself. If the repository is
       # offline, then the script will keep retrying until it comes online.
       if [ $RETRY -eq 1 ]; then
          echo "Delaying $DELAY seconds"
          sleep $DELAY
          # exponential backoff, where the sum of all times are less than 1 hour 
          # before exiting.
          DELAY=$(( $DELAY * 2 ))
          if [ $DELAY -gt 1024 ]; then
             # ERROR
             rm -f $PUBKEY_FN
             rm -f $STAGE2_FN
             rm -f $STAGE2_SIGNATURE_FN
             rm -f $STAGE2_SIGNATURE_URL
             return 1
          fi
       fi
    done

    echo "GOT STAGE2!"
    # NOTE: rename tmp file to proper filename
    mkdir -p $PREFIX/packages
    cp $STAGE2_FN $PREFIX/packages/$STAGE2_FILE 
    rm -f $PUBKEY_FN
    rm -f $STAGE2_FN
    rm -f $STAGE2_SIGNATURE_FN
    rm -f $STAGE2_SIGNATURE_URL
}

function save_etag_from_url () {
    local url=$1
    local file=$( basename $url )
    ETAG=$( get_etag_from_url $url )
    mkdir -p $PREFIX/etag/
    if [ -z "$ETAG" ] ; then
        return 1
    else
        echo $ETAG > $PREFIX/etag/$file
        return 0
    fi
}

function get_etag_from_url () {
    local url=$1
    ETAG=`curl -s -I $url | grep ETag | awk '{print $2}'`
    echo $ETAG
}

function get_etag_from_file () {
    local url=$1
    local file=$( basename $url )
    ETAG=`cat $PREFIX/etag/$file 2> /dev/null`
    echo $ETAG
}

function package_setup () {
    local url=$1
    local filename=$( basename $url )
    get_package_and_verify $url
    RETVAL=$?
    if [ $RETVAL -eq 0 ] ; then
        if unpack_and_install $filename ; then
            save_etag_from_url $url
        fi
    fi
}

function package_is_latest () {
    local url=$1
    local url_et=$( get_etag_from_url $url )
    local cached_et=$( get_etag_from_file $url )
    
    if test "$url_et" == "$cached_et" ; then
        return 0
    else
        return 1
    fi
}

function enough_disk_space () {
    blocks_available=`df | grep dev | awk '{print $4}'`
    if [ $blocks_available -gt 10240 ] ; then
        # at least 10MB are available.
        return 0
    fi
    return 1
}

function unpack_and_install () {
    filename=$1
    mkdir -p $PREFIX/install
    cd $PREFIX/install
    if [ -d current ] ; then
        suffix=`date +%Y-%m-%d-%H:%M`
        if [ -d previous-$suffix ] ; then
            suffix=${suffix}-0
        fi
        mv current previous-$suffix
    fi
    mkdir -p current
    tar -C current -zxf $PREFIX/packages/$filename
    if [ -f current/install.sh ] ; then
        cd current;
        ./install.sh
        return $?
    else
        echo "NO SUCH FILE: $PREFIX/install/current/install.sh" 
        return 1
    fi
}


